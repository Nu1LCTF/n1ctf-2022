# N1-Desktop-Apps

>Well, in the end, only 2 teams solved the challenge.
>
>Im so sorry first.
>
>I made a mistake and the anti-debug `--inspect` is not working...
>
>So, one of the teams accidentally solved the chall.
>



## Idea

The design idea for this challenge came from the real world, in many cases we consider electron's source code protection to be weak, but this can be complex.

## Solve

It's an Electron Application.

We know that the logic of such programs is in `resources/app.asar` 

In this game, I added junk data in `app.asar`, so you can't use `asar extract` directly.

But you can still extract a single file.

You can write a script to extract all valid documents or repair the header file of the file.

The entry point is `main.js`, and the key file is `main.jsc` and it is a v8 bytecode file.

We can see the `preload` field is `preload.js`, it's load `preload.jsc`, it's also a v8 bytecode file.

**So how to disassemble v8 bytecode file?**

v8 itself has disassembled function. 

In Node, we can use `-print-bytecode` to print the file's v8 bytecode. However, you can only disassemble the source code, not the JSC file.

So we can achieve our goal by modifying the v8 source code.

We chose d8.

Be aware that the bytecode corresponding to different v8 versions may differ, so choose the same or a similar version if possible.

We get the version information from the game:

- electron version: `22.0.0-alpha.3`

- v8 version: `10.8.79-electron.0`

Compile d8

```sh
export PATH=`pwd`/depot_tools:"$PATH"
gclient sync 
fetch v8
git pull origin
gclient sync
git checkout 10.8.79
```

Enable disassembler and object print

```sh
tools/dev/v8gen.py x64.release -- \
>   v8_enable_disassembler=true \
>   v8_enable_object_print=true

ninja -C out.gn/x64.release d8
```

- JSC files are generated by the `v8::internal::CodeSerializer::Serialize`
- Disassembly requires calling the `v8::internal::BytecodeArray::Disassemble`

`Serialize` corresponds to the `Deserialize` prototype located at `src/snapshot/code-serializer.h`

```c++
  V8_WARN_UNUSED_RESULT static MaybeHandle<SharedFunctionInfo> Deserialize(
      Isolate* isolate, AlignedCachedData* cached_data, Handle<String> source,
      ScriptOriginOptions origin_options);
```

Its return `SharedFunctionInfo` class has `GetActiveBytecodeArray` method which can get `BytecodeArray` for disassembly.

So,

- Read File, construct parameter `cached_data`
- Deserialize, Get `SharedFunctionInfo` object
- Disassemble, Get `BytecodeArray` by `GetActiveBytecodeArray`, call `BytecodeArray.Disassemble` to disassemble

It should be noted that th，ere are two checks in the Deserialize.

- source_hash

- flags_hash

add self defined function in `d8.cc`

```cpp
// TODO: modify start

static void PrintArrayBoilerplateDescription(i::Isolate *_isolate, std::ostream* stream, i::Handle<i::Object> constant) {

  i::Handle<i::ArrayBoilerplateDescription> array_boilerplate = i::Handle<i::ArrayBoilerplateDescription>::cast(constant);
  i::FixedArrayBase constant_elements = array_boilerplate->constant_elements(_isolate);
  i::FixedArray copy_constant_elements = i::FixedArray::cast(constant_elements);
  i::FixedArray::cast(copy_constant_elements).Print(*stream);


  for (int j = 0; j < copy_constant_elements.length(); j++) {
    if (copy_constant_elements.get(j).IsArrayBoilerplateDescription()) {
      auto ele = i::FixedArray::get(copy_constant_elements, j, _isolate);
      PrintArrayBoilerplateDescription(_isolate, stream, ele);
    }
    // *stream << copy_constant_elements.get(j).IsArrayBoilerplateDescription() << " ";
  }
}


static void PrintV8String(std::ostream* stream,
                                                i::String string) {
  *stream << '"';
  for (int i = 0, length = string.length(); i < length; ++i) {
    *stream << i::AsEscapedUC16ForJSON(string.Get(i));
  }
  *stream << '"';
}

static void PrintConstant(
    i::Isolate *_isolate, std::ostream* stream, i::Handle<i::Object> constant) {
  if (constant->IsSmi()) {
    *stream << "Smi [";
    i::Smi::cast(*constant).SmiPrint(*stream);
    *stream << "]";
  } else {
    *stream << i::HeapObject::cast(*constant).map().instance_type();
    if (constant->IsHeapNumber()) {
      *stream << " [";
      i::HeapNumber::cast(*constant).HeapNumberShortPrint(*stream);
      *stream << "]";
    } else if (constant->IsString()) {
      *stream << " [";
      PrintV8String(stream, i::String::cast(*constant));
      *stream << "]";
    } else if (constant->IsArrayBoilerplateDescription()) {
      *stream << "-> ";
      PrintArrayBoilerplateDescription(_isolate, stream, constant);
    }
  }
}

static void PrintConstantPool(
    i::Isolate *_isolate, std::ostream* stream, i::FixedArray constant_pool) {
  *stream << "constant pool: [\n";
  int num_constants = constant_pool.length();
  if (num_constants > 0) {
    for (int i = 0; i < num_constants; ++i) {
      *stream << "  ";
      PrintConstant(_isolate, stream, i::FixedArray::get(constant_pool, i, _isolate));
      *stream << ",\n";
    }
  }
  *stream << "]\n";
}

static void Disassemble(i::Isolate *_isolate, v8::internal::BytecodeArray bytecode) {
  internal::OFStream os(stdout);
  bytecode.Disassemble(os);
  auto consts = bytecode.constant_pool();

  PrintConstantPool(_isolate, &os, consts);

  for (int i = 0; i < consts.length(); i++) {
    auto obj = consts.get(i);
    if (obj.IsSharedFunctionInfo()) {
      i::SharedFunctionInfo shared = v8::internal::SharedFunctionInfo::cast(obj);
      os << "Function name " << shared.Name().ToCString().get() << "\n";
      Disassemble(_isolate, shared.GetActiveBytecodeArray());
    }
  }
}

void Shell::LoadJSC(const v8::FunctionCallbackInfo<v8::Value>& args) {
  auto isolate = reinterpret_cast<i::Isolate*>(args.GetIsolate());
  for (int j = 0; j < args.Length(); j++) {
    String::Utf8Value filename(args.GetIsolate(), args[j]);
    if (*filename == NULL) {
      args.GetIsolate()->ThrowError("Error loading file");
      return;
    }
    int length = 0;
    auto filedata = reinterpret_cast<i::byte*>(ReadChars(*filename, &length));
    if (filedata == NULL) {
      args.GetIsolate()->ThrowError("Error reading file");
      return;
    }
    auto scriptdata = new i::AlignedCachedData(filedata, length);
    auto source = isolate->factory()
                      ->NewStringFromUtf8(base::CStrVector("source"))
                      .ToHandleChecked();
    v8::ScriptOriginOptions origin_options(true, true);
    auto fun = i::CodeSerializer::Deserialize(isolate, scriptdata, source, origin_options)
                   .ToHandleChecked();
    Disassemble(isolate, fun->GetActiveBytecodeArray());
  }
}
// TODO: modify end


add global api.
```

```c++
global_template->Set(isolate, "loadjsc", FunctionTemplate::New(isolate, LoadJSC));
```

Patch sanitycheck in `src/snapshot/deserializer.cc`, `src/snapshot/code-serializer.cc`

After the patch, compile again.

```sh
ninja -C out.gn/x64.release d8
```

test it.

```sh
> out.gn/x64.release/d8 --print-bytecode -e "let a = 1;"

[generated bytecode for function:  (0x071900199c39 <SharedFunctionInfo>)]
Bytecode length: 6
Parameter count 1
Register count 1
Frame size 8
Bytecode age: 0
         0x71900199ca6 @    0 : 0d 01             LdaSmi [1]
         0x71900199ca8 @    2 : 25 02             StaCurrentContextSlot [2]
         0x71900199caa @    4 : 0e                LdaUndefined
         0x71900199cab @    5 : aa                Return
Constant pool (size = 0)
Handler Table (size = 0)
Source Position Table (size = 0)
```



For the v8 bytecode, you can refer to the source code.

https://github.com/v8/v8/blob/10.8.79/src/interpreter/interpreter-generator.cc

Try to disassemble `renderer.jsc`

```sh
> out.gn/x64.release/d8 --print-bytecode -e "loadjsc('renderer.jsc')"

···
Constant pool (size = 15)
0x32f800199ee9: [FixedArray] in OldSpace
 - map: 0x32f800002229 <Map(FIXED_ARRAY_TYPE)>
 - length: 15
           0: 0x32f800199f2d <String[62]: #./a783a16e1a0b62e833626fbb895b8b16026ecfa5f7db3cfe7f10f11afb43>
           1: 0x32f800006911 <String[5]: #Proxy>
           2: 0x32f800199f79 <String[9]: #checkflag>
           3: 0x32f800199f91 <ObjectBoilerplateDescription[3]>
           4: 0x32f800199fa5 <SharedFunctionInfo apply>
           5: 0x32f800005721 <String[5]: #apply>
           6: 0x32f80019f379 <String[2]: #_B>
           7: 0x32f80019f389 <ObjectBoilerplateDescription[3]>
           8: 0x32f80019a0dd <SharedFunctionInfo get>
           9: 0x32f800005fed <String[3]: #get>
          10: 0x32f80019f39d <String[2]: #_Y>
          11: 0x32f80019f3ad <ObjectBoilerplateDescription[3]>
          12: 0x32f80019a1e1 <SharedFunctionInfo get>
          13: 0x32f80019a371 <SharedFunctionInfo>
          14: 0x32f80019f3c1 <String[33]: #chgsp.i\na,v)} {";(SuLdrnEymkotfel>
```

We can disassemble the file in the same way



Notice here that `ArrayBoilerplateDescription`

```sh
> out.gn/x64.release/d8 --print-bytecode -e "[1, 2]"
[generated bytecode for function:  (0x22b500199c39 <SharedFunctionInfo>)]
Bytecode length: 6
Parameter count 1
Register count 1
Frame size 8
Bytecode age: 0
         0x22b500199cc6 @    0 : 7a 00 00 25       CreateArrayLiteral [0], [0], #37
         0x22b500199cca @    4 : c5                Star0
         0x22b500199ccb @    5 : aa                Return
Constant pool (size = 1)
0x22b500199c99: [FixedArray] in OldSpace
 - map: 0x22b500002229 <Map(FIXED_ARRAY_TYPE)>
 - length: 1
           0: 0x22b500199c8d <ArrayBoilerplateDescription PACKED_SMI_ELEMENTS, 0x22b500199c7d <FixedArray[2]>>
Handler Table (size = 0)
Source Position Table (size = 0)
```

`[1, 2]` is represented in the bytecode as `<ArrayBoilerplateDescription PACKED_SMI_ELEMENTS, 0x22b500199c7d <FixedArray[2]>>`, not as a specific value

This is why `PrintConstantPool` and related methods have been added to the Patch example above.



We focus on two files: 

- `renderer.jsc` 

- `a783a16e1a0b62e833626fbb895b8b16026ecfa5f7db3cfe7f10f11afb43.jsc`



`checkflag` is contained in `a783a16e1a0b62e833626fbb895b8b16026ecfa5f7db3cfe7f10f11afb43.jsc`.

we were able to get the pseudo-code after analyzing the bytecode.

```js
function o0o00Oo0O(A, B) {
	var n = A.length;
	var C = [];
	for (var i = 0; i < n; i++) {
		C[i] = [];
		for (var j = 0; j < n; j++) {
			C[i][j] = 0;
			for (var k = 0; k < n; k++) {
				C[i][j] += A[i][k] * B[k][j];
			}
		}
	}
	return C;
}
exports._Y = [
	[541507686, 541510001, 541513960, 541522663, 541523788, 541513223, 541508668],
	[541511232, 541512425, 541514906, 541509172, 541523961, 541511268, 541509601],
	[541509098, 541508323, 541501201, 541508450, 541522761, 541510206, 541520695],
	[541515241, 541502702, 541504508, 541513407, 541510178, 541500537, 541514273],
	[541508548, 541515005, 541515461, 541508974, 541522144, 541510757, 541510745],
	[541515465, 541500241, 541507472, 541513335, 541511841, 541502534, 541514129],
	[541510436, 541512845, 541502376, 541512089, 541511005, 541500720, 541508940]
];

exports._B = [
	[24596, 25037, 24625, 24598, 25070, 24591, 24590],
	[24597, 24596, 25069, 24625, 24598, 25070, 24591],
	[24590, 24597, 24596, 25037, 25081, 24598, 25070],
	[24591, 24590, 24597, 24596, 25037, 24625, 24598],
	[25038, 24591, 24590, 24597, 24596, 25037, 25078],
	[24598, 25070, 24591, 24590, 24597, 24596, 24589],
	[24625, 24598, 25070, 24591, 24590, 24597, 24596]
];

exports.checkflag = (flag) => {

	if (flag.length != 49) {
		return false;
	}

	const A = [];
	for (let i = 0; i < 7; i++) {
		A[i] = [];
		for (let j = 0; j < 7; j++) {
			A[i][j] = flag.charCodeAt(i*7+j);
		}
	}
    
	const result = o0o00Oo0O(A, this._B);

	for (let i = 0; i < 7; i++) {
		for (let j = 0; j < 7; j++) {
			if (result[i][j] !== this._Y[i][j]) {
				return false;
			}
		}
	}
	return true;
}

```

It's obviously a simple matrix multiplication.

But when we analyze `renderer.js`, it listens for input and hooks `_B` and `_Y` using `Proxy`.

```javascript
const h = require("./a783a16e1a0b62e833626fbb895b8b16026ecfa5f7db3cfe7f10f11afb43");

let __B = new Proxy(h._B, {
get(target, propKey, receiver) {
  let result = target[propKey];
  let arr = [...result];
  for (let i = 0; i < arr.length; i++) {
    arr[i] ^= 0xbeef;
    arr[i] -= 0xdead;
  }
  return arr;
},
});
h._B = __B;

let __Y = new Proxy(h._Y, {
    get(target, propKey, receiver) {
      let result = target[propKey];
      let arr = [...result];
      arr = arr.reverse();
      for (let i = 0; i < arr.length; i++) {
        arr[i] = 0xfeebdaed & ~arr[i] | ~0xfeebdaed & arr[i];
        arr[i] = 0xdeadbeef & ~arr[i] | ~0xdeadbeef & arr[i];
      }
      return arr;
    },
    });
h._Y = __Y;

```

Then, it's easy to solve.

exp:

```javascript
let _B = [
	[41022, 45573, 39758, 40677, 48362, 44403, 42084],
	[41955, 43622, 39931, 41526, 47256, 46827, 43586],
	[38709, 44604, 40779, 42848, 49939, 42721, 41448],
	[48675, 49275, 44576, 45757, 55294, 51436, 47595],
	[43099, 43111, 40162, 41324, 47815, 47359, 42950],
	[48531, 51268, 46243, 45685, 56210, 51027, 47819],
	[41294, 49458, 43359, 46491, 53162, 45199, 44838]
];

for (let i = 0; i < _B.length; i++) {
	for (let j = 0; j < _B[i].length; j++) {
        // A & ~B | ~A & B === A XOR B
		_B[i][j] = 0xfeebdaed & ~_B[i][j] | ~0xfeebdaed & _B[i][j];
		_B[i][j] = 0xdeadbeef & ~_B[i][j] | ~0xdeadbeef & _B[i][j];
	}
	_B[i] = _B[i].reverse();
}

let _Y = [
	[541507686, 541510001, 541513960, 541522663, 541523788, 541513223, 541508668],
	[541511232, 541512425, 541514906, 541509172, 541523961, 541511268, 541509601],
	[541509098, 541508323, 541501201, 541508450, 541522761, 541510206, 541520695],
	[541515241, 541502702, 541504508, 541513407, 541510178, 541500537, 541514273],
	[541508548, 541515005, 541515461, 541508974, 541522144, 541510757, 541510745],
	[541515465, 541500241, 541507472, 541513335, 541511841, 541502534, 541514129],
	[541510436, 541512845, 541502376, 541512089, 541511005, 541500720, 541508940]
];

for (let i = 0; i < _Y.length; i++) {
	for (let j = 0; j < _Y[i].length; j++) {
        // A & ~B | ~A & B === A XOR B
		_Y[i][j] = 0xfeebdaed & ~_Y[i][j] | ~0xfeebdaed & _Y[i][j];
		_Y[i][j] = 0xdeadbeef & ~_Y[i][j] | ~0xdeadbeef & _Y[i][j];
	}
	_Y[i] = _Y[i].reverse();
}
```



```python
import numpy as np

_Y = np.array([
    [41022, 45573, 39758, 40677, 48362, 44403, 42084], 
	[41955, 43622, 39931, 41526, 47256, 46827, 43586], 
	[38709, 44604, 40779, 42848, 49939, 42721, 41448], 
	[48675, 49275, 44576, 45757, 55294, 51436, 47595], 
	[43099, 43111, 40162, 41324, 47815, 47359, 42950], 
	[48531, 51268, 46243, 45685, 56210, 51027, 47819], 
	[41294, 49458, 43359, 46491, 53162, 45199, 44838],
])
_B = np.array([
    [78, 117, 49, 76, 84, 51, 52],
    [77, 78, 85, 49, 76, 84, 51],
    [52, 77, 78, 117, 105, 76, 84],
    [51, 52, 77, 78, 117, 49, 76],
    [116, 51, 52, 77, 78, 117, 108],
    [76, 84, 51, 52, 77, 78, 53],
    [49, 76, 84, 51, 52, 77, 78]
])

inv_secret = np.linalg.inv(_B)
mat = np.dot(_Y, inv_secret)
print(mat)
flag = ""
for i in range(7):
    for j in range(7):
        flag += chr(round(mat[i][j]))
print(flag)
```

flag: `N1CTF{y3Ea4h_tHIs_1S_NlDeskT0p_4pPS_n0w_enj0y_1T}`
